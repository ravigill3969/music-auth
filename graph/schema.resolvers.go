package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"music-auth/graph/model"
	"music-auth/internal/middleware"
	"net/http"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*model.AuthPayload, error) {
	token, user, err := r.AuthService.Register(username, email, password)
	if err != nil {
		return nil, err
	}

	rw := middleware.GetResponseWriter(ctx)
	if rw == nil {
		return nil, fmt.Errorf("could not get response writer")
	}

	http.SetCookie(rw, &http.Cookie{
		Name:     "auth_token",
		Value:    token,
		HttpOnly: true,
		Secure:   false,
		Path:     "/",
		SameSite: http.SameSiteLaxMode,
	})

	return &model.AuthPayload{

		User: &model.User{
			ID:       user.ID.String(),
			Email:    user.Email,
			Username: user.Username,
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.LoginResponse, error) {
	token, err := r.AuthService.Login(email, password)
	if err != nil {
		return nil, err
	}

	rw := middleware.GetResponseWriter(ctx)
	if rw == nil {
		return nil, fmt.Errorf("could not get response writer")
	}

	http.SetCookie(rw, &http.Cookie{
		Name:     "auth_token",
		Value:    token,
		HttpOnly: true,
		Secure:   false,
		Path:     "/",
		SameSite: http.SameSiteLaxMode,
	})

	return &model.LoginResponse{
		Success: true,
		Message: "Logged in successfully",
	}, nil
}

// GetUserInfo is the resolver for the getUserInfo field.
func (r *queryResolver) GetUserInfo(ctx context.Context) (*model.GetUserInfoResponse, error) {
	user, err := r.AuthService.GetUserInfo(ctx)

	fmt.Println(user)

	if err != nil {
		return nil, err
	}

	return &model.GetUserInfoResponse{
		Success: true,
		Message: "User info reterieved",
		User:    user.User,
	}, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, oldPassword string, newPassword string) (*model.BasicResponse, error) {
	res, err := r.AuthService.UpdatePassword(ctx, oldPassword, newPassword)

	if err != nil {
		return nil, err
	}

	return &model.BasicResponse{
		Success: res.Success,
		Message: res.Message,
	}, nil
}

// Pending -------------- ||
//                       \  /
//	   					  \/
//

// UpdateEmail is the resolver for the updateEmail field.
func (r *mutationResolver) UpdateEmail(ctx context.Context, newEmail string) (*model.BasicResponse, error) {
	err := r.AuthService.UpdateEmail(ctx, newEmail)

	if err != nil {
		return nil, err
	}

	return &model.BasicResponse{
		Success: true,
		Message: "email update successfully",
	}, nil
}

// UpdateUsername is the resolver for the updateUsername field.
func (r *mutationResolver) UpdateUsername(ctx context.Context, newUsername string) (*model.BasicResponse, error) {
	err := r.AuthService.UpdateUsername(ctx, newUsername)

	if err != nil {
		return nil, err
	}

	return &model.BasicResponse{
		Success: true,
		Message: "username update successfull",
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
